Project Structure
1. Root Level Files

docker-compose.yml - Orchestrates both services and MySQL containers
.env - Environment variables (passwords, secrets)
.gitlab-ci.yml - CI/CD pipeline for GitLab
README.md - Project documentation

2. Blog Service
Complete Spring Boot service with:

User authentication with JWT
Role-based access control (ADMIN, WRITER, READER)
Post management with slug generation
Link management
Image reference management
Feign client for communication with Image Service

3. Image Service
Separate microservice for image storage:

Stores images as BLOBs in MySQL
REST API for upload/download/delete
File validation and size limits
Public endpoint for viewing images

4. Key Features
Security:

JWT authentication
BCrypt password encryption
Role-based authorization
Environment variables for secrets

Database Design:

Two separate MySQL containers
Blog database: users, roles, posts, image references, links
Image database: images with BLOB storage

Microservice Communication:

Feign client for service-to-service calls
Shared network in Docker Compose

CI/CD Pipeline:

Build, test, package stages
Docker image creation and registry push
GitLab-specific configuration

5. Environment Variables
All sensitive data is externalized to .env file:

Database credentials
JWT secrets
Service URLs

6. Development vs Production

Separate property files for different environments
Different logging levels
SQL query visibility control

Usage Instructions

Setup: Copy the .env file and configure your values
Run: Use docker-compose up -d to start all services
Access: Blog service on port 8080, Image service on port 8081

The application follows microservice best practices with proper separation of concerns, security, and scalability. The use of BLOBs for image storage as requested allows for backup reasons, though in production you might want to consider object storage for better performance.

